# JavaScript — MASTER MAP

## PHASE 0 — Programming & Computing Foundations

- [x] Expressions vs statements
- [x] Control flow (`if`, `switch`)
- [x] Loops (conceptual)
- [x] Truthy / falsy values
- [x] Error handling basics
- [x] Reading stack traces
- [ ] Big-O notation (time / space)
- [ ] Algorithmic thinking basics

### Looping (Absolute Fluency)

- [x] `for`
- [ ] `while`
- [ ] `do…while`
- [ ] `for…of`
- [ ] `for…in`

---

## PHASE 1 — Execution Model (Core of JS)

- [x] Execution context
- [x] Call stack
- [x] Lexical scope
- [x] Scope chain
- [x] Hoisting (functions vs vars)
- [x] Closures (creation, lifetime)
- [x] Strict mode
- [x] `this` binding rules
- [ ] Tail call concept (theoretical)

---

## PHASE 2 — Variables & Memory Semantics

- [x] `var` vs `let` vs `const`
- [x] Block scope
- [x] Temporal Dead Zone
- [x] Reassignment vs mutation
- [x] Value vs reference
- [ ] Stack vs heap (mental model)
- [ ] Pass-by-sharing reality

---

## PHASE 3 — Types & Coercion (Bug Battlefield)

- [x] Primitive types
- [x] Objects as reference types
- [x] Type coercion rules
- [x] `==` vs `===`
- [ ] Abstract Equality Algorithm
- [ ] `typeof` quirks
- [ ] `instanceof`
- [ ] Boxing / unboxing

---

## PHASE 4 — Operators & Expressions

- [x] Arithmetic operators
- [x] Assignment operators
- [x] Comparison operators
- [x] Logical operators
- [x] Short-circuiting
- [x] Ternary operator
- [x] Optional chaining (`?.`)
- [x] Nullish coalescing (`??`)
- [ ] Defaulting (`||` vs `??`)
- [ ] Bitwise operators
- [ ] Comma operator (edge)

---

## PHASE 5 — Functions (The Soul of JS)

- [x] Function declarations
- [x] Function expressions
- [x] Arrow functions
- [x] Arrow vs normal semantics
- [x] Parameters vs arguments
- [x] Default parameters
- [x] Rest parameters
- [x] Higher-order functions
- [x] Callbacks
- [x] Closures in practice
- [ ] IIFE
- [ ] Partial application
- [ ] Currying
- [ ] Function composition

---

## PHASE 6 — Numbers & Math (Seriously)

- [ ] Number type limits (IEEE 754)
- [ ] Floating-point precision
- [ ] `NaN`, `Infinity`
- [ ] `Number.isNaN`
- [ ] `Number.isFinite`
- [ ] `toFixed()` (returns string)
- [ ] `toPrecision`
- [ ] `Math.round`
- [ ] `Math.floor`
- [ ] `Math.ceil`
- [ ] `Math.trunc`
- [ ] `Math.random`
- [ ] `Math.min` / `Math.max`
- [ ] `BigInt`
- [ ] Safe integer limits
- [ ] Parsing numbers safely

---

## PHASE 7 — Strings (Deep Control)

- [x] Immutability
- [x] `.length`
- [x] `.includes`
- [x] `.startsWith` / `.endsWith`
- [x] `.toLowerCase` / `.toUpperCase`
- [x] `.trim`
- [ ] `.slice`
- [ ] `.substring`
- [ ] `.split`
- [ ] `.join`
- [ ] Template literals
- [ ] Unicode / UTF-16
- [ ] String normalization

---

## PHASE 8 — Arrays (Mastery Required)

- [x] Creation & indexing
- [x] Immutability patterns
- [x] `map`
- [x] `filter`
- [x] `reduce`
- [x] Defensive counting
- [ ] `some`
- [ ] `every`
- [ ] `find`
- [ ] `findIndex`
- [ ] `slice`
- [ ] `concat`
- [ ] `sort` (mutation trap)
- [ ] `flat`
- [ ] `Array.isArray`
- [ ] Typed arrays

---

## PHASE 9 — Objects (Structural Power)

- [x] Object literals
- [x] Property access
- [x] Dynamic keys
- [x] Mutation vs copying
- [x] Shallow copy
- [ ] `Object.keys`
- [ ] `Object.values`
- [ ] `Object.entries`
- [ ] Object iteration
- [ ] Deep cloning strategies
- [ ] Property descriptors
- [ ] `Object.freeze`

---

## PHASE 10 — Equality & Identity

- [x] Primitive equality
- [ ] Reference equality
- [ ] Shallow vs deep compare
- [ ] Structural sharing
- [ ] Identity bugs in state systems

---

## PHASE 11 — Errors & Defensive JS

- [ ] `try / catch`
- [ ] Throwing errors
- [ ] Error objects
- [ ] Custom errors
- [ ] Guard clauses
- [ ] Fail-fast philosophy
- [ ] Defensive APIs

---

## PHASE 12 — Async JavaScript (Critical)

- [ ] Callback patterns
- [ ] Promises
- [ ] Promise states
- [ ] `.then` chains
- [ ] `async / await`
- [ ] Error propagation
- [ ] Parallel vs sequential
- [ ] `Promise.all`
- [ ] `Promise.race`
- [ ] `Promise.any`
- [ ] AbortController

---

## PHASE 13 — Event Loop & Concurrency

- [ ] Event loop mental model
- [ ] Call stack vs queue
- [ ] Microtasks vs macrotasks
- [ ] Timers
- [ ] Blocking vs non-blocking
- [ ] Starvation scenarios

---

## PHASE 14 — Modules & Architecture

- [ ] ES modules
- [ ] Import / export mechanics
- [ ] Live bindings
- [ ] Circular deps
- [ ] Side-effect control

---

## PHASE 15 — Prototypes & Internals

- [ ] Prototype chain
- [ ] `__proto__` vs `prototype`
- [ ] Constructor functions
- [ ] `new`
- [ ] Method lookup
- [ ] Inheritance patterns

---

## PHASE 16 — Memory & Performance

- [ ] Garbage collection
- [ ] Memory leaks
- [ ] Closure retention
- [ ] Allocation patterns
- [ ] Performance profiling

---

## PHASE 17 — Standard Library Power

- [ ] `Date`
- [ ] `Intl`
- [ ] `JSON`
- [ ] `RegExp` (full mastery)
- [ ] `Map`
- [ ] `Set`
- [ ] `WeakMap`
- [ ] `WeakSet`

---

## PHASE 18 — Environment APIs

- [ ] Browser APIs (DOM, events)
- [ ] Fetch API
- [ ] Storage APIs
- [ ] Node.js globals
- [ ] File system basics

---

## PHASE 19 — Tooling & Ecosystem

- [ ] npm
- [ ] package.json
- [ ] Versioning
- [ ] Linters
- [ ] Formatters
- [ ] Bundlers (conceptual)

---

## PHASE 20 — GOD CHECK

You are a JS god when you can:

- [ ] Predict coercion without testing
- [ ] Debug async by reasoning
- [ ] Explain event loop verbally
- [ ] Spot reference bugs instantly
- [ ] Write mutation-free code by reflex
- [ ] Read JS specs without fear
