# Tailwind CSS Mastery Map (Utility-First, No Cargo Cult)

## Phase 0 — Prerequisites (Assumed)

- [ ] CSS box model
- [ ] Flexbox basics
- [ ] Basic responsive design concepts
- [ ] HTML semantics awareness

---

## Phase 1 — Tailwind Core Philosophy (Critical)

- [ ] Utility-first mental model
- [ ] Composition over abstraction
- [ ] Why Tailwind avoids semantic class names
- [ ] When Tailwind is a good fit
- [ ] When Tailwind is NOT a good fit
- [ ] Tailwind vs traditional CSS mental comparison

---

## Phase 2 — Installation & Project Setup

- [ ] Tailwind via PostCSS
- [ ] Tailwind with Vite
- [ ] Tailwind with React
- [ ] Content paths & purge logic
- [ ] Development vs production builds
- [ ] JIT compiler behavior

---

## Phase 3 — Core Utility Categories (Fluency)

### Layout

- [ ] `container`
- [ ] `box-border` / `box-content`
- [ ] `block`, `inline`, `flex`, `grid`, `hidden`
- [ ] Positioning (`relative`, `absolute`, `fixed`, `sticky`)
- [ ] Z-index utilities

### Spacing

- [ ] Margin utilities
- [ ] Padding utilities
- [ ] Space-between utilities
- [ ] Negative spacing

### Sizing

- [ ] Width / height utilities
- [ ] Min / max sizing
- [ ] Viewport-based sizing
- [ ] Aspect-ratio utilities

---

## Phase 4 — Flexbox & Grid (High Leverage)

### Flexbox

- [ ] `flex-direction`
- [ ] `justify-*`
- [ ] `items-*`
- [ ] `content-*`
- [ ] `flex-grow` / `flex-shrink`
- [ ] `flex-basis`
- [ ] Gap utilities

### Grid

- [ ] Grid template columns/rows
- [ ] Auto-fit / auto-fill patterns
- [ ] Grid gaps
- [ ] Grid alignment
- [ ] Responsive grid layouts

---

## Phase 5 — Typography & Visual Styling

- [ ] Font families
- [ ] Font sizes
- [ ] Font weights
- [ ] Line height
- [ ] Letter spacing
- [ ] Text alignment
- [ ] Text decoration
- [ ] Color utilities
- [ ] Opacity
- [ ] Backgrounds & gradients

---

## Phase 6 — Borders, Effects & Interactions

- [ ] Border width / color / style
- [ ] Border radius
- [ ] Box shadows
- [ ] Ring utilities
- [ ] Outline utilities
- [ ] Hover / focus / active states
- [ ] Disabled states
- [ ] Cursor utilities
- [ ] Transitions
- [ ] Animations (basic)

---

## Phase 7 — Responsive Design (Critical)

- [ ] Mobile-first philosophy
- [ ] Breakpoint system (`sm`, `md`, `lg`, `xl`, `2xl`)
- [ ] Responsive modifiers
- [ ] Conditional layouts per breakpoint
- [ ] Hiding/showing per breakpoint
- [ ] Common responsive patterns

---

## Phase 8 — State & Variant Modifiers

- [ ] Pseudo-class variants (`hover:`, `focus:`, `active:`)
- [ ] Group variants (`group-hover`)
- [ ] Peer variants (`peer-*`)
- [ ] Attribute-based variants
- [ ] Arbitrary variants
- [ ] Combining variants safely

---

## Phase 9 — Arbitrary Values & Advanced Utilities

- [ ] Arbitrary values (`w-[42px]`)
- [ ] Arbitrary colors
- [ ] Arbitrary selectors
- [ ] Escaping special characters
- [ ] When arbitrary values are justified
- [ ] When they are a smell

---

## Phase 10 — Customization & Theming

- [ ] Tailwind config structure
- [ ] Custom colors
- [ ] Custom spacing scale
- [ ] Custom fonts
- [ ] Extending vs overriding defaults
- [ ] Theme tokens vs hard-coded values

---

## Phase 11 — Composition Patterns (Real-World)

- [ ] Component extraction strategy
- [ ] Reusable UI patterns
- [ ] Class grouping discipline
- [ ] Avoiding utility explosion
- [ ] When to extract components
- [ ] When NOT to extract components

---

## Phase 12 — Tailwind + React Patterns

- [ ] Conditional class rendering
- [ ] `clsx` / `classnames` usage
- [ ] State-driven styling
- [ ] Variant-driven components
- [ ] Avoiding unreadable JSX
- [ ] Colocation of styles and logic

---

## Phase 13 — Maintainability & Scale

- [ ] Naming conventions for components
- [ ] Design consistency enforcement
- [ ] Avoiding one-off styles
- [ ] Refactoring Tailwind-heavy components
- [ ] Team conventions

---

## Phase 14 — Performance & Output Awareness

- [ ] Purge behavior understanding
- [ ] Build size implications
- [ ] Runtime vs build-time cost
- [ ] Avoiding unused variants
- [ ] Debugging missing styles

---

## Phase 15 — Common Mistakes & Anti-Patterns

- [ ] Treating Tailwind as inline CSS
- [ ] Overusing arbitrary values
- [ ] Recreating CSS frameworks inside Tailwind
- [ ] Fighting the spacing scale
- [ ] Styling without layout intent

---

## Phase 16 — Professional Judgment Layer

- [ ] When Tailwind improves velocity
- [ ] When CSS modules are better
- [ ] When design systems outgrow Tailwind
- [ ] Tradeoffs vs traditional CSS
- [ ] Tailwind as a tool, not an identity
