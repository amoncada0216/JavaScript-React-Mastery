# JavaScript — MASTER MAP (UPDATED)

## PHASE 0 — Programming & Computing Foundations

- [x] Expressions vs statements
- [x] Control flow (`if`, `switch`)
- [x] Loops (conceptual)
- [x] Truthy / falsy values
- [x] Error handling basics
- [x] Reading stack traces
- [x] Big-O notation (time / space)
- [x] Algorithmic thinking basics

### Looping (Absolute Fluency)

- [x] `for`
- [x] `while`
- [x] `do…while`
- [x] `for…of`
- [x] `for…in`

---

## PHASE 1 — Execution Model (Core of JS)

- [x] Execution context
- [x] Call stack
- [x] Lexical scope
- [x] Scope chain
- [x] Hoisting (functions vs vars)
- [x] Closures (creation, lifetime)
- [x] Strict mode
- [x] `this` binding rules
- [ ] Tail call concept (theoretical)

---

## PHASE 2 — Variables & Memory Semantics

- [x] `var` vs `let` vs `const`
- [x] Block scope
- [x] Temporal Dead Zone
- [x] Reassignment vs mutation
- [x] Value vs reference
- [ ] Stack vs heap (mental model)
- [ ] Pass-by-sharing reality

---

## PHASE 3 — Types & Coercion (Bug Battlefield)

- [x] Primitive types
- [x] Objects as reference types
- [x] Type coercion rules
- [x] `==` vs `===`
- [ ] Abstract Equality Algorithm
- [ ] `typeof` quirks
- [ ] `instanceof`
- [ ] Boxing / unboxing

---

## PHASE 4 — Operators & Expressions

- [x] Arithmetic operators
- [x] Assignment operators
- [x] Comparison operators
- [x] Logical operators
- [x] Short-circuiting
- [x] Ternary operator
- [x] Optional chaining (`?.`)
- [x] Nullish coalescing (`??`)
- [x] Defaulting (`||` vs `??`)
- [ ] Bitwise operators
- [ ] Comma operator (edge)

---

## PHASE 5 — Functions (The Soul of JS)

- [x] Function declarations
- [x] Function expressions
- [x] Arrow functions
- [x] Arrow vs normal semantics
- [x] Parameters vs arguments
- [x] Default parameters
- [x] Rest parameters
- [x] Higher-order functions
- [x] Callbacks
- [x] Closures in practice
- [ ] IIFE
- [ ] Partial application
- [ ] Currying
- [ ] Function composition

---

## PHASE 6 — Numbers & Math (Seriously)

- [ ] Number type limits (IEEE 754)
- [ ] Floating-point precision
- [ ] `NaN`, `Infinity`
- [ ] `Number.isNaN`
- [ ] `Number.isFinite`
- [x] `toFixed()` (returns string)
- [ ] `toPrecision`
- [ ] `Math.round`
- [x] `Math.floor`
- [x] `Math.ceil`
- [ ] `Math.trunc`
- [x] `Math.random`
- [ ] `Math.min` / `Math.max`
- [ ] `BigInt`
- [ ] Safe integer limits
- [ ] Parsing numbers safely

---

## PHASE 7 — Strings (Deep Control)

- [x] Immutability
- [x] `.length`
- [x] `.includes`
- [x] `.startsWith` / `.endsWith`
- [x] `.toLowerCase` / `.toUpperCase`
- [x] `.trim`
- [x] `.slice`
- [ ] `.substring`
- [ ] `.split`
- [ ] `.join`
- [ ] Template literals
- [ ] Unicode / UTF-16
- [x] String normalization

---

## PHASE 8 — Arrays (Mastery Required)

- [x] Creation & indexing
- [x] Immutability patterns
- [x] `map`
- [x] `filter`
- [x] `reduce`
- [x] Defensive counting
- [x] `some`
- [x] `every`
- [x] `find`
- [x] `findIndex`
- [x] `slice`
- [x] `concat`
- [ ] `sort` (mutation trap)
- [ ] `flat`
- [x] `Array.isArray`
- [ ] Typed arrays

---

## PHASE 9 — Objects (Structural Power)

- [x] Object literals
- [x] Property access
- [x] Dynamic keys
- [x] Mutation vs copying
- [x] Shallow copy
- [x] `Object.keys`
- [x] `Object.values`
- [x] `Object.entries`
- [ ] Object iteration
- [ ] Deep cloning strategies
- [ ] Property descriptors
- [ ] `Object.freeze`

---

## PHASE 10 — Equality & Identity

- [x] Primitive equality
- [x] Reference equality
- [ ] Shallow vs deep compare
- [ ] Structural sharing
- [x] Identity bugs in state systems

---

## PHASE 11 — Errors & Defensive JS

- [x] `try / catch`
- [x] Throwing errors
- [x] Error objects
- [ ] Custom errors
- [x] Guard clauses
- [x] Fail-fast philosophy
- [ ] Defensive APIs

---

## PHASE 12 — Async JavaScript (Critical)

- [x] Callback patterns
- [x] Promises
- [x] Promise states
- [x] `.then` chains
- [x] `async / await`
- [x] Error propagation
- [x] Parallel vs sequential
- [x] `Promise.all`
- [x] `Promise.race`
- [x] `Promise.any`
- [x] AbortController

---

## PHASE 13 — Event Loop & Concurrency

- [x] Event loop mental model
- [x] Call stack vs queue
- [x] Microtasks vs macrotasks
- [x] Timers
- [x] Blocking vs non-blocking
- [x] Starvation scenarios

---

## PHASE 14 — Modules & Architecture

- [x] ES modules
- [x] Import / export mechanics
- [x] Live bindings
- [x] Circular deps
- [x] Side-effect control

---

## PHASE 15 — Prototypes & Internals

- [x] Prototype chain
- [x] `__proto__` vs `prototype`
- [x] Constructor functions
- [x] `new`
- [x] Method lookup
- [ ] Inheritance patterns

---

## PHASE 16 — Memory & Performance

- [x] Garbage collection
- [ ] Memory leaks
- [x] Closure retention
- [ ] Allocation patterns
- [ ] Performance profiling

---

## PHASE 17 — Standard Library Power

- [ ] `Date`
- [ ] `Intl`
- [x] `JSON`
- [ ] `RegExp` (full mastery)
- [x] `Map`
- [x] `Set`
- [x] `WeakMap`
- [x] `WeakSet`

---

## PHASE 18 — Environment APIs

- [x] Browser APIs (DOM, events)
- [x] Fetch API
- [x] Storage APIs
- [ ] Node.js globals
- [ ] File system basics

---

## PHASE 19 — Tooling & Ecosystem

- [ ] npm
- [ ] package.json
- [ ] Versioning
- [ ] Linters
- [ ] Formatters
- [ ] Bundlers (conceptual)

---

## PHASE 20 — GOD CHECK

You are a JS god when you can:

- [x] Predict coercion without testing
- [x] Debug async by reasoning
- [x] Explain event loop verbally
- [x] Spot reference bugs instantly
- [x] Write mutation-free code by reflex
- [ ] Read JS specs without fear
