# Product / UX Thinking — Logical Mastery Map (From Code Executor to Product Engineer)

## 1 — What Product & UX Actually Are

- [ ] Product ≠ UI
- [ ] UX ≠ visual design
- [ ] Software as a problem-solving tool
- [ ] Users do not care about your implementation
- [ ] Features are hypotheses, not truths

---

## 2 — Users, Goals, and Context

- [ ] Users vs customers vs stakeholders
- [ ] Primary vs secondary users
- [ ] User goals vs business goals
- [ ] Context of use (device, time, stress, environment)
- [ ] Why “edge cases” are often real users

---

## 3 — Jobs-To-Be-Done Thinking

- [ ] Jobs vs features
- [ ] Functional jobs
- [ ] Emotional jobs
- [ ] Social jobs
- [ ] Why users “hire” products
- [ ] Avoiding solution-first thinking

---

## 4 — Problem Definition (Most Teams Skip This)

- [ ] Symptoms vs root problems
- [ ] Framing problems clearly
- [ ] Constraints as inputs, not blockers
- [ ] Writing a good problem statement
- [ ] Knowing when the problem is unclear

---

## 5 — UX as System Behavior

- [ ] UX emerges from system behavior
- [ ] Latency is UX
- [ ] Error states are UX
- [ ] Empty states are UX
- [ ] Defaults are UX
- [ ] Performance is UX

---

## 6 — Mental Models & Affordances

- [ ] User mental models
- [ ] Matching system behavior to expectations
- [ ] Affordances and signifiers
- [ ] Consistency vs innovation
- [ ] Why “intuitive” usually means “familiar”

---

## 7 — Interaction Design Fundamentals

- [ ] Action → feedback loops
- [ ] Immediate vs delayed feedback
- [ ] Preventing errors vs handling errors
- [ ] Reversibility (undo)
- [ ] Progressive disclosure
- [ ] Cognitive load management

---

## 8 — UX States (Critical for Engineers)

- [ ] Loading states
- [ ] Empty states
- [ ] Error states
- [ ] Success states
- [ ] Partial failure states
- [ ] Silent failures (anti-pattern)

---

## 9 — Accessibility as Product Quality

- [ ] Accessibility ≠ compliance
- [ ] Accessibility improves UX for everyone
- [ ] Keyboard users as power users
- [ ] Screen readers as stress tests
- [ ] Inclusive defaults

---

## 10 — Forms & User Input (Where UX Lives)

- [ ] Friction vs safety
- [ ] Validation timing
- [ ] Inline vs submit-time errors
- [ ] Error message clarity
- [ ] Required fields honesty
- [ ] Autofill as UX feature

---

## 11 — Decision Making & Tradeoffs

- [ ] UX vs performance
- [ ] UX vs security
- [ ] UX vs implementation complexity
- [ ] When “worse UX” is the right call
- [ ] Communicating tradeoffs clearly

---

## 12 — Metrics & Signals (Reality Check)

- [ ] Vanity metrics vs meaningful metrics
- [ ] Conversion vs satisfaction
- [ ] Quantitative vs qualitative feedback
- [ ] Instrumentation basics
- [ ] Knowing what NOT to measure

---

## 13 — Working With Designers & PMs

- [ ] Translating designs into behavior
- [ ] Asking clarifying questions
- [ ] Challenging designs constructively
- [ ] Saying “this will break users”
- [ ] Being a partner, not an order-taker

---

## 14 — Product Thinking for Engineers

- [ ] Thinking beyond the ticket
- [ ] Suggesting simpler solutions
- [ ] Catching product bugs early
- [ ] Designing for change
- [ ] Avoiding over-engineering

---

## 15 — Failure Patterns in Product & UX

- [ ] Feature bloat
- [ ] Shiny UI, broken flow
- [ ] Ignoring empty/error states
- [ ] Designing for ideal users only
- [ ] Solving the wrong problem well

---

## GOD CHECK — Product / UX Thinking

You’re done when you can:

- [ ] Explain _why_ a feature exists
- [ ] Identify UX bugs in code reviews
- [ ] Argue for user-impacting changes
- [ ] Design flows, not just screens
- [ ] Build less while delivering more value
