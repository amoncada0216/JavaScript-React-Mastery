# Data Structures & Algorithms — Mastery Map

## 1 — What DSA Really Is

- [x] Problem-solving vs memorization
- [x] Time complexity vs real-world speed
- [x] Space complexity tradeoffs
- [x] Why constraints matter more than syntax
- [ ] Why “works on small input” means nothing

---

## 2 — Complexity Fundamentals (Ground Truth)

- [ ] Big O notation
- [ ] Best, average, worst case
- [ ] Amortized analysis
- [ ] Constant factors reality
- [ ] When Big O lies to you

---

## 3 — Arrays & Strings

- [ ] Static vs dynamic arrays
- [ ] Indexing vs searching cost
- [ ] Insertions and deletions
- [ ] Two-pointer technique
- [ ] Sliding window patterns

---

## 4 — Hashing & Hash Tables

- [ ] Hash functions intuition
- [ ] Collision handling
- [ ] Load factor
- [ ] Time complexity reality
- [ ] When NOT to use a hash map

---

## 5 — Linked Lists

- [ ] Singly vs doubly linked lists
- [ ] Pointer manipulation
- [ ] Traversal cost
- [ ] Reversal patterns
- [ ] Cycle detection (Floyd)

---

## 6 — Stacks & Queues

- [ ] LIFO vs FIFO
- [ ] Stack applications
- [ ] Queue implementations
- [ ] Deques
- [ ] Monotonic stack / queue

---

## 7 — Recursion (The Mental Model)

- [ ] Base case discipline
- [ ] Recursive state
- [ ] Call stack mechanics
- [ ] Tail recursion
- [ ] When recursion is a bad idea

---

## 8 — Trees (Core Structure)

- [ ] Tree terminology
- [ ] Binary trees vs BST
- [ ] Tree traversal (DFS, BFS)
- [ ] Height and depth
- [ ] Recursive vs iterative traversal

---

## 9 — Binary Search Trees

- [ ] BST invariants
- [ ] Insert, search, delete
- [ ] Balanced vs unbalanced trees
- [ ] Degenerate cases
- [ ] Why BSTs fail in interviews

---

## 10 — Heaps & Priority Queues

- [ ] Min heap vs max heap
- [ ] Heap operations
- [ ] Heapify
- [ ] Top-K problems
- [ ] When heaps beat sorting

---

## 11 — Graph Fundamentals

- [ ] Graph representations
- [ ] Directed vs undirected
- [ ] Weighted vs unweighted
- [ ] Adjacency list vs matrix
- [ ] Traversal basics

---

## 12 — Graph Traversal Algorithms

- [ ] BFS mechanics
- [ ] DFS mechanics
- [ ] Visited state handling
- [ ] Connected components
- [ ] Cycle detection

---

## 13 — Shortest Path Algorithms

- [ ] BFS for unweighted graphs
- [ ] Dijkstra intuition
- [ ] Why negative weights break things
- [ ] Bellman-Ford basics
- [ ] When NOT to use Dijkstra

---

## 14 — Sorting Algorithms

- [ ] Comparison vs non-comparison sorts
- [ ] Bubble, insertion, selection (why they matter)
- [ ] Merge sort
- [ ] Quick sort
- [ ] Stability and in-place tradeoffs

---

## 15 — Searching Algorithms

- [ ] Linear search
- [ ] Binary search invariants
- [ ] Boundary handling
- [ ] Lower bound / upper bound
- [ ] Binary search on answer

---

## 16 — Greedy Algorithms

- [ ] Greedy choice property
- [ ] Optimal substructure
- [ ] Interval problems
- [ ] Scheduling problems
- [ ] Why greedy often fails

---

## 17 — Dynamic Programming (DP)

- [ ] Overlapping subproblems
- [ ] Optimal substructure
- [ ] Memoization vs tabulation
- [ ] State definition discipline
- [ ] Transition design

---

## 18 — Classic DP Patterns

- [ ] 1D DP
- [ ] 2D DP
- [ ] Knapsack pattern
- [ ] Subsequence problems
- [ ] Grid DP

---

## 19 — Bit Manipulation

- [ ] Binary representation
- [ ] Bitwise operators
- [ ] Masking techniques
- [ ] XOR tricks
- [ ] Space optimization with bits

---

## 20 — Advanced Data Structures

- [ ] Tries
- [ ] Union-Find (Disjoint Set)
- [ ] Segment Trees
- [ ] Fenwick Trees
- [ ] When complexity is justified

---

## 21 — Common Pitfalls

- [ ] Off-by-one errors
- [ ] Ignoring constraints
- [ ] Wrong data structure choice
- [ ] Overengineering solutions
- [ ] Memorizing without understanding

---

## 22 — Daily Practice (Non-Negotiable)

- [ ] Solve 1 problem cold
- [ ] Explain solution out loud
- [ ] Analyze time and space
- [ ] Rewrite solution cleaner
- [ ] Identify reusable pattern

---

## GOD CHECK — Data Structures & Algorithms

You’re done when you can:

- [ ] Choose the right data structure instinctively
- [ ] Derive complexity without guessing
- [ ] See patterns across problems
- [ ] Explain solutions clearly
- [ ] Solve unseen problems under pressure
